using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Diagnostics;
using System.Collections;
using System.Xml;
using System.Threading;
using TrafficViewerSDK.Options;
using TrafficViewerSDK.Importers;

namespace TrafficViewerSDK
{
	/// <summary>
	/// Instantiates TrafficViewerFile type object which has properties common to any file
	/// A Traffic Viewer File is a zip which unpacked has the following structure:
	///     index.xls //lists all the requests in the traffic file with their main information
	///     searchindexes.xml //contains searches, up to a number, criteria,range,results request ids comma separated
	///     customdata.xml //contains request custom data
	///     rawtraffic.dat //contains the raw traffic data
	///		profile.xml//contains the parsing profile
	/// </summary>
	public class TrafficViewerFile : BaseTrafficDataAccessor
	{

		#region Fields

		private const string INDEX_FILE_NAME = "Index.xls";
		private const string RAW_TRAFFIC_FILE_NAME = "RawTraffic.dat";
		private const string CUSTOM_DATA_FILE_NAME = "CustomData.xml";
		private const string SEARCH_INDEXES_FILE_NAME = "SearchIndexes.xml";
		private const string OPTIONS_FILE_NAME = "ParsingOptions.xml";
		
		/// <summary>
		/// The HTD file version
		/// </summary>
		public static Version FileVersion = new Version("1.0.0");

		private string _tempFileFolder;
		/// <summary>
		/// Returns the directory containing the tvf files
		/// </summary>
		public string TempFileFolder
		{
			get { return _tempFileFolder; }
		}
		private string _predefinedTempHomeDir = null;

		
		private FileStream _rawTrafficFile;
		
		

		private string _importedFileName = String.Empty;
		private object _sender = null;
		/// <summary>
		/// Parser used to import a file
		/// </summary>
		private ITrafficParser _parser;

		private int ESTIMATED_LINE_SIZE = 1024;

		private bool _enableDefrag = false;
		/// <summary>
		/// If turned on optimizes the size of the tvf but also increases the save time
		/// </summary>
		public bool EnableDefrag
		{
			get { return _enableDefrag; }
			set { _enableDefrag = value; }
		}

		/// <summary>
		/// Lock used to ensure syncroneus write to the raw traffic data file
		/// </summary>
		private object _lockWrite = new object();
		
		/// <summary>
		/// Whether to delete the temp folder when the traffic file is closed
		/// </summary>
		private bool _keepOnClose = false;

		#endregion

		#region Tail Code

		private FileStream _tailSource;


		/// <summary>
		/// Turns on monitoring the attached traffic log
		/// </summary>
		public bool Tail
		{
			get { return _tailInProgress; }
			set
			{
				if (value == true)
				{
					if (_importedFileName != String.Empty)
					{
						_tailInProgress = true;

						_tailSource = File.Open(_importedFileName, FileMode.Open,
								FileAccess.Read, FileShare.ReadWrite);

						//start the monitoring thread
						Thread t = new Thread(new ThreadStart(DoTail));
						//enable the thread through a bool flag
						_tailRunThread = true;
						t.Start();

					}
				}
				else
				{
					_tailInProgress = false;
					//change the thread flag in order to stop it
					_tailRunThread = false;
					Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.Normal;
					SetState(AccessorState.Idle);
				}
			}
		}

		/// <summary>
		/// Frequency of the tail heartbeat
		/// </summary>
		private int TAIL_FREQUENCY = 100;

		/// <summary>
		/// Controls the tail heartbeat
		/// </summary>
		private bool _tailRunThread = true;

		private void DoTail()
		{
            //do a fast load of all the requests that might have been added meanwhile
            SetState(AccessorState.Loading);
            this.ResumeImport();
            SetState(AccessorState.Tailing);
			_tailSource.Position = _tailSource.Length;
			do
			{
				if (_tailSource.Length - _tailSource.Position != 0)
				{
					_tailSource.Position = _tailSource.Length;
					_parser.Tail(-1);
				}
				else
				{
					Thread.Sleep(TAIL_FREQUENCY);
				}
			}
			while (_tailRunThread);
		}

		#endregion

		#region Private Methods

		/// <summary>
		/// Creates the TrafficViewerFile file structure in the temp folder 
		/// </summary>
		private string MakeTempFolder()
		{
			try
			{
				string tempLocation;

				if (_predefinedTempHomeDir != null)
				{
					tempLocation = _predefinedTempHomeDir;
				}
				else
				{
					//use temp as the default temp directory
					tempLocation = Environment.GetEnvironmentVariable("temp");
				}

				//get the process id
				string pid = Process.GetCurrentProcess().Id.ToString();
				// prevent duplicate autogenerated file names when creating multiple traffic viewer files at once
				tempLocation = String.Format(@"{0}\htd.{1}.{2}", tempLocation, pid, GetHashCode());

				
				if (!Directory.Exists(tempLocation))
				{
					Directory.CreateDirectory(tempLocation);	
				}


				return tempLocation;
			}
			catch (Exception ex)
			{
				SdkSettings.Instance.Logger.Log(TraceLevel.Error, "Cannot make temp folder: {0}", ex.Message);
			}
			return String.Empty;
		}

		/// <summary>
		/// Opens a different file handle to read data so we don't interfere with an eventual tail operation
		/// </summary>
		/// <param name="startPosition"></param>
		/// <param name="length"></param>
		protected override byte[] DataRead(long startPosition, int length)
		{
			_rawTrafficFile.Flush();
			FileStream trafficFileReader = File.Open(_rawTrafficFile.Name, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite);
			byte[] data = new byte[length];
			trafficFileReader.Position = startPosition;
			int bytesRead = trafficFileReader.Read(data, 0, length);
			if (bytesRead == 0)
			{
				data = new byte[0];
			}
			trafficFileReader.Close();
			return data;
		}

		/// <summary>
		/// Writes traffic data to the HDD
		/// </summary>
		/// <param name="buffer"></param>
		/// <param name="offset"></param>
		/// <param name="length"></param>
		protected override void DataWrite(byte[] buffer, int offset, int length)
		{
			lock (_lockWrite)
			{               
				_rawTrafficFile.Write(buffer, offset, length);
			}
		}

		/// <summary>
		/// Returns the current position in the internal raw traffic file
		/// </summary>
		protected override long WritePosition
		{
			get
			{
				lock (_lockWrite)
				{
					return _rawTrafficFile.Position;
				}
			}
		}

		/// <summary>
		/// Creates a new Traffic Viewer File
		/// </summary>
		private void New()
		{
			SetState(AccessorState.Loading);
			_tempFileFolder = MakeTempFolder();
			_rawTrafficFile = File.Open(_tempFileFolder + "\\" + RAW_TRAFFIC_FILE_NAME, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite);
			_requestInfos = new SortedDictionary<int, TVRequestInfo>();
			_firstIndex = _lastIndex = -1;
			SetState(AccessorState.Idle);

		}

		private void Load()
		{
			SetState(AccessorState.Loading);
			//Open the decompressed files

			//load index
			byte[] bytes;
			string line;
			int currentIndex = -1, count = 0;
			TVRequestInfo currentRequestInfo;
			_requestInfos = new SortedDictionary<int, TVRequestInfo>();
			_rawTrafficFile = File.Open(_tempFileFolder + "\\" + RAW_TRAFFIC_FILE_NAME, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite);

			XmlDocument customDataFile = new XmlDocument();
            customDataFile.XmlResolver = null;
			if (File.Exists(_tempFileFolder + "\\" + CUSTOM_DATA_FILE_NAME))
			{
				customDataFile.Load(_tempFileFolder + "\\" + CUSTOM_DATA_FILE_NAME);
			}

			Profile = new ParsingOptions();

			//Load the parsing options that were used to create this file
			if (File.Exists(_tempFileFolder + "\\" + OPTIONS_FILE_NAME))
			{
				Profile.Load(_tempFileFolder + "\\" + OPTIONS_FILE_NAME);
			}


			_firstIndex = -1;
			FileStream indexFile = File.Open(_tempFileFolder + "\\" + INDEX_FILE_NAME, FileMode.OpenOrCreate, FileAccess.ReadWrite);
			
			while ((bytes = Utils.ReadLine(indexFile, ESTIMATED_LINE_SIZE)) != null)
			{
				try
				{
					line = Utils.ByteToString(bytes);

					currentRequestInfo = new TVRequestInfo();

					currentRequestInfo.ReadValues(line);

					currentIndex = currentRequestInfo.Id;

					AddRequestInfo(currentRequestInfo);

					//load the data for the first requests in the buffer
					if (!RequestDataCache.Instance.MaxSizeReached)
					{
						this.LoadRequestData(currentIndex);
						this.LoadResponseData(currentIndex);
					}

					//load custom fields
					XmlNodeList customFields = customDataFile.SelectNodes(
						String.Format("/Requests/Request[@id='{0}']/Field", currentIndex));
					if (customFields.Count > 0)
					{
						currentRequestInfo.CustomFields = new Dictionary<string, string>();
						foreach (XmlNode node in customFields)
						{
							currentRequestInfo.CustomFields.Add(node.Attributes["name"].Value, node.InnerText);
						}
					}


					count++;

				}
				catch (Exception ex)
				{
					SdkSettings.Instance.Logger.Log(TraceLevel.Error, "Error loading request from index: {0}", ex.Message);
				}
			}
			//set the position of the rawdatafile to the end
			_rawTrafficFile.Position = _rawTrafficFile.Length;

			//close the other files
			indexFile.Close();
			
			//set the keep on close flag to false
			_keepOnClose = false;
			SetState(AccessorState.Idle);
		}

		#endregion

		#region Public Methods

		/// <summary>
		/// Constructor
		/// </summary>
		public TrafficViewerFile():this(null)
		{
			
		}

		/// <summary>
		/// When passing a predefinedTempHomeDir the temp folders holding tvf files will be created in this location
		/// </summary>
		/// <param name="predefinedTempHomeDir">Directory where the traffic viewer data files folders will be stored. If this value
		/// is not specified the temp environment variable will be used instead</param>
		public TrafficViewerFile(string predefinedTempHomeDir)
		{
			_predefinedTempHomeDir = predefinedTempHomeDir;
			New();
		}


		/// <summary>
		/// Opens existing traffic viewer file
		/// </summary>
		/// <param name="path">Path to file</param>
		public void Open(string path)
		{
			//close the existing file 
			Close(_keepOnClose);

			SetState(AccessorState.Unpacking);
			//Decompress the TVF
			_tempFileFolder = MakeTempFolder();

			Utils.DecompressFiles(path, _tempFileFolder);

			//Load the requests
			Load();

		}

		/// <summary>
		/// Opens a TVF that has been already unzipped
		/// </summary>
		/// <param name="tempFolder">The location of the data files</param>
		public void OpenUnpacked(string tempFolder)
		{
			//close the existing file
			Close(_keepOnClose);

			//set the temp folder to the unpacked folder
			_tempFileFolder = tempFolder;

			Load();
		}

		/// <summary>
		/// Saves current file
		/// </summary>
		/// <param name="path">Path to file</param>
		public void Save(string path)
		{
			if (State != AccessorState.Idle)
			{
				SdkSettings.Instance.Logger.Log(TraceLevel.Error, "Cannot save a busy Traffic Viewer file !");
				return;
			}

			if (File.Exists(path))
			{
				File.Delete(path);
			}

			SaveUnpacked();

			SetState(AccessorState.Saving);

			_rawTrafficFile.Close();
			
			//compress all the files
			Utils.CompressFiles(_tempFileFolder, path);

			_rawTrafficFile = File.Open(_tempFileFolder + "\\" + RAW_TRAFFIC_FILE_NAME, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite);
			_rawTrafficFile.Position = _rawTrafficFile.Length;
			
			SetState(AccessorState.Idle);
		}

		/// <summary>
		/// Saves the data from the memory on the hard drive
		/// </summary>
		public void SaveUnpacked()
		{

			SetState(AccessorState.Saving);

			//disabling buffering requests
			_cacheEnabled = false;

			XmlNode topNode, requestNode;//used for the custom data file
			XmlDocument customDataFile = new XmlDocument();
            customDataFile.XmlResolver = null;
			topNode = customDataFile.CreateElement("Requests");

			//delete the old index file
			string indexFilePath = _tempFileFolder + "\\" + INDEX_FILE_NAME;
			if(File.Exists(indexFilePath))
			{
				File.Delete(indexFilePath);
			}
			//create a new index file
			FileStream indexFile = File.Open(indexFilePath, FileMode.OpenOrCreate, FileAccess.ReadWrite);
			FileStream defragFile = null;

			if (_enableDefrag)
			{
				//create temporary defrag file
				defragFile = File.Open(_tempFileFolder + "\\" + RAW_TRAFFIC_FILE_NAME + ".defrag", FileMode.OpenOrCreate, FileAccess.ReadWrite);
			}

			long position = 0;
			lock (_lockData)
			{
				foreach (KeyValuePair<int, TVRequestInfo> request in _requestInfos)
				{
					if (_enableDefrag)
					{
						//save the data associated with this request
						//copy request data to defrag data file
                        bool isEncrypted = request.Value.IsEncrypted;
                        request.Value.IsEncrypted = false; //prevent decrypting the request automatically
						byte[] reqData = LoadRequestData(request.Key);
						byte[] respData = LoadResponseData(request.Key);
                        request.Value.IsEncrypted = isEncrypted;

						request.Value.RequestStartPosition = position;
						defragFile.Write(reqData, 0, request.Value.RequestLength);
						position += request.Value.RequestLength;

						request.Value.ResponseStartPosition = position;
						defragFile.Write(respData, 0, request.Value.ResponseLength);
						position += request.Value.ResponseLength;
					}

					//write index line
					Utils.WriteLine(indexFile, request.Value.ToString());


					//save custom fields if any
					requestNode = request.Value.GetCustomFieldsXml();
					if (requestNode != null)
					{
						requestNode = customDataFile.ImportNode(requestNode, true);
						requestNode.Attributes.Append(customDataFile.CreateAttribute("id"));
						requestNode.Attributes["id"].Value = request.Key.ToString();
						topNode.AppendChild(requestNode);
					}
				}



				if (_enableDefrag)
				{
					_rawTrafficFile.Close();
					//replace rawTrafficFile with the defrag file
					defragFile.Close();
					File.Delete(_rawTrafficFile.Name);
					File.Move(defragFile.Name, _rawTrafficFile.Name);
					//re-open the _raw data file
					_rawTrafficFile = File.Open(_tempFileFolder + "\\" + RAW_TRAFFIC_FILE_NAME, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite);
				}
			}
			//save the custom data
			customDataFile.AppendChild(topNode);
			customDataFile.Save(_tempFileFolder + "\\" + CUSTOM_DATA_FILE_NAME);

			//save the parsing options
			Profile.SaveAs(_tempFileFolder + "\\" + OPTIONS_FILE_NAME);

			//close the index file
			indexFile.Close();

			//set the position to the end of the file
			_rawTrafficFile.Position = _rawTrafficFile.Length;

			//re-enable buffering
			_cacheEnabled = true;

			SetState(AccessorState.Idle);
		
		}

        

		/// <summary>
		/// Clears the current file
		/// </summary>
		/// <param name="shouldClearSource">Specifies if the source file should also be cleared</param>
		public void Clear(bool shouldClearSource)
		{
			SetState(AccessorState.Clearing);
			try
			{
				//stop any ongoing loading operations
				if (shouldClearSource && _parser != null)
				{
					if (_parser.ParserStatus != TrafficParserStatus.Stopped)
					{
						_parser.Stop();
					}

					//wait a second for the parser to stop
					do
					{
						Thread.Sleep(1000);
					}
					while (_parser.ParserStatus != TrafficParserStatus.Stopped);

					_parser.ClearSource();
				}

				//Close the current file and delete all data
				Close(false);
				//Make a new file
				New();

			}
			catch (Exception ex)
			{
				SdkSettings.Instance.Logger.Log(TraceLevel.Error, "Cannot clear Traffic Viewer File: {0}", ex.Message);
			}
			
			SetState(AccessorState.Idle);
		}

		/// <summary>
		/// Closes the current file
		/// </summary>
		/// <param name="keepTempData">Wether to clear the temporary folder data for this file or not</param>
		public void Close(bool keepTempData)
		{
			Close(keepTempData, true);
		}

		/// <summary>
		/// Closes the current file
		/// </summary>
		/// <param name="keepTempData">Wether to clear the temporary folder data for this file or not</param>
		/// <param name="notifyGui">Notifies the gui that the file was closed</param>
		private void Close(bool keepTempData, bool notifyGui)
		{
			try
			{
				_keepOnClose = keepTempData;
				if (notifyGui)
				{
					SetState(AccessorState.Clearing);
				}

				//in the case the user wants to keep the data save the memory data on the HDD
				if (keepTempData)
				{
					SaveUnpacked();
					_rawTrafficFile.Close();
				}
				else
				{
					_rawTrafficFile.Close();
					if (Directory.Exists(_tempFileFolder))
					{
						Directory.Delete(_tempFileFolder, true);
					}
				}

				//clear the request headers
				_requestInfos.Clear();
				//clear the buffer
				RequestDataCache.Instance.Clear();
				//if required skip clearing the temp data
				//let the GUI know that the object was cleared
				if (notifyGui)
				{
					InvokeDataCleared();
				}
			}
			catch (Exception err)
			{
				SdkSettings.Instance.Logger.Log(TraceLevel.Error, "Cannot cleanup temporary directory: {0}", err.Message);
			}
		}

		/// <summary>
		/// On destructore call Close
		/// </summary>
		~TrafficViewerFile()
		{
			Close(_keepOnClose, false);
		}


		/// <summary>
		/// Imports from a Raw Traffic Log
		/// </summary>
		/// <param name="parser">parser object containing the parsing logic</param>
		/// <param name="rawTrafficLog">the raw traffic file to use</param>
		/// <param name="profile">The parsing options for the current parsing operation</param>
		public void StartImport(ITrafficParser parser, string rawTrafficLog, ParsingOptions profile)
		{
			if (parser != null)
			{
				SetState(AccessorState.Loading);
				//save parsing options
				Profile = profile;
				//save target path
				_importedFileName = rawTrafficLog;
				//save parser
				_parser = parser;
				//start parsing
				_parser.Parse(rawTrafficLog, this, profile);
				SetState(AccessorState.Idle);
			}
		}

		/// <summary>
		/// Imports from a object
		/// </summary>
		/// <param name="parser">parser object containing the parsing logic</param>
		/// <param name="sender">the raw traffic file to use</param>
		/// <param name="profile">The parsing options for the current parsing operation</param>
		public void StartImport(ITrafficParser parser, object sender, ParsingOptions profile)
		{
			if (parser != null)
			{
				SetState(AccessorState.Loading);
				//save parsing options
				Profile = profile;
				//save parser
				_parser = parser;
				//save sender object
				_sender = sender;
				//start parsing
				_parser.Parse(sender, this, profile);
				SetState(AccessorState.Idle);
			}
		}

		/// <summary>
		/// Pauses the import operation
		/// </summary>
		public void StopImport()
		{
			if (_parser != null)
			{
				_parser.Stop();
			}
			SetState(AccessorState.Idle);
		}

		/// <summary>
		/// Resumes the import from where it was left. Used in tail for example.
		/// </summary>
		public void ResumeImport()
		{
			if (_parser != null)
			{
				SetState(AccessorState.Loading);
				_parser.Resume();
			}
		}

		#endregion

	}
}
