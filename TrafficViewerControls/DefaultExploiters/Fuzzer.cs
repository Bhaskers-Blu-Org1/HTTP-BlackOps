using CommonControls;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Security;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using TrafficViewerControls.Browsing;
using TrafficViewerInstance;
using TrafficViewerSDK;
using TrafficViewerSDK.Http;

namespace TrafficViewerControls.DefaultExploiters
{
	public partial class Fuzzer : Form
	{
		public const string FUZZ = Constants.FUZZ_STRING;
		private int _numThreads = 100;
		const int PAYLOAD_LIMIT = 1000;
		private int _minLen = 0;
		private int _maxLen = 0;
		private long _elapsedSeconds = 0;
		private object _lock = new object();
		private object _lockCount = new object();
		private long _count = 0;
		private Queue<string> _payloads = new Queue<string>();
		private bool _fuzzOn = false;
		private bool _abort = false;
		private double _combinations;
		private byte[] _characters;

        private FuzzerOptions _options = new FuzzerOptions();

		private List<TVRequestInfo> _requests = new List<TVRequestInfo>();
		/// <summary>
		/// The request to fuzz
		/// </summary>
		public List<TVRequestInfo> Requests
		{
			get { return _requests; }
			set { _requests = value; }
		}
		
		TrafficViewerFile _outputFile = TrafficViewer.Instance.TrafficViewerFile;
		private int _matches = 0;
		private Dictionary<string,TVRequestInfo> _requestsToFuzz;
		private ITrafficDataAccessor _dataAccessor;
		/// <summary>
		/// Data accessor
		/// </summary>
		public ITrafficDataAccessor DataAccessor
		{
			get { return _dataAccessor; }
			set { _dataAccessor = value; }
		}
		
		public Fuzzer()
		{
			InitializeComponent();

		}

		private long Fact(int n)
		{

			long res = n;
			do
			{
				n--;
				if (n > 1)
				{
					res *= n;
				}
				else
				{
					break;
				}
			}
			while (true);
			return res;
		}

		private double CalculateCombinations(int charsLen,int minLen, int maxLen)
		{ 
			double res = 0;
			for(int k=minLen;k<=maxLen;k++)
			{
				res += Math.Pow(charsLen, k);		
			}
			return res;
		}

		private void StartClick(object sender, EventArgs e)
		{
            if (_fuzzOn) return;

            _options.MatchPattern = _textPattern.Text;
            _options.ReversePattern = _reversePattern.Checked;
            

			GenerateRequestsToFuzz();


			ErrorBox error = new ErrorBox();
			
			if (!String.IsNullOrWhiteSpace(_fileSelector.Text))
			{
				_outputFile = new TrafficViewerFile();
				_outputFile.Save(_fileSelector.Text);
				if (!File.Exists(_fileSelector.Text))
				{
					error.Show("Invalid result file location");
					return;
				}
                _options.OutputFile = _fileSelector.Text;
			}
			else
			{
				_outputFile = TrafficViewer.Instance.TrafficViewerFile;
				_outputFile.SetState(AccessorState.Tailing);
			}

            if (!int.TryParse(_textNumThreads.Text, out _numThreads))
            {
                error.Show("Invalid number of threads specified");

                return;
            }
            _options.NumberOfThreads = _numThreads;
            _options.Save();
            GenerateAndRunPayloads();
		}

        private void GenerateAndRunPayloads()
        {
            
            ErrorBox error = new ErrorBox();
            _characters = new byte[0];

            var defs = _options.GetRangeDefinitionList();
            double charRangeCombinations = 0;
            foreach (var def in defs)
            {
                if (def.Status != FuzzerRangeStatus.Enabled) continue;//skip disabled definitions

                if (def.Type == FuzzerRangeType.CharRange && _characters.Length == 0)
                {

                    String[] rangeSets = def.Value.Split(',');
                    StringBuilder charsBuilder = new StringBuilder();

                    foreach (String rangeSet in rangeSets)
                    {
                        String[] ranges = rangeSet.Split('-');

                        byte min;
                        byte max;

                        if (ranges.Length == 1)
                        {
                            min = (byte)Convert.ToChar(ranges[0]);
                            max = min;
                        }
                        else if (ranges.Length == 2)
                        {
                            min = (byte)Convert.ToChar(ranges[0]);
                            max = (byte)Convert.ToChar(ranges[1]);
                        }
                        else
                        {
                            error.Show("Invalid range specified");
                            return;
                        }


                        //generate chars to fuzz with
                        for (byte i = min; i <= max; i++)
                        {
                            charsBuilder.Append((char)i);
                        }
                    }

                    string chars = charsBuilder.ToString();
                    _characters = Constants.DefaultEncoding.GetBytes(chars);
                    _minLen = def.StartLen;
                    _maxLen = def.MaxLen;
                    if (_minLen < 1 || _minLen > _maxLen)
                    {
                        error.Show("Invalid length limits specified. Must be 1 or higher");
                        return;
                    }
                    charRangeCombinations = CalculateCombinations(_characters.Length, _minLen, _maxLen);
                }
                else
                {
                    List<string> files = new List<string>();
                    if (def.Value.Contains("*"))
                    {
                        string[] fname = def.Value.Split(new char[] { '*' }, 2);
                        if (Directory.Exists(fname[0]))
                        {
                            files.AddRange(Directory.GetFiles(fname[0], "*" + fname[1]));
                        }
                        else
                        {
                            error.Show("Dictionary contains a wildcard but we can't find the directory it refers to.");
                            return;
                        }

                    }
                    else if (!File.Exists(def.Value))
                    {
                        error.Show("Dictionary not found");
                        return;
                    }
                    else
                    {
                        files.Add(def.Value);
                    }

                    foreach (string file in files)
                    {
                        StreamReader sr = new StreamReader(file);
                        string line;
                        while ((line = sr.ReadLine()) != null)
                        {
                            _payloads.Enqueue(line);
                        }
                    }

                    
                    
                }

                _combinations = _payloads.Count + charRangeCombinations;
                _combinations = _requestsToFuzz.Count * _combinations;

            }

            button1.ForeColor = Color.LightGray;
            _fileSelector.Enabled = false;
            _count = 0;
            _matches = 0;
            _elapsedSeconds = 0;
            _labelNumRequests.Text = "0";
            _labelMatches.Text = "0";
            _textElapsed.Text = "";

            _textCombinations.Text = _combinations.ToString();
            _abort = false;
            BackgroundWorker fuzzWorker = new BackgroundWorker();
            fuzzWorker.DoWork += FuzzWork;
            _fuzzOn = true;
            fuzzWorker.RunWorkerAsync();

            Thread.Sleep(100);

            for (int i = 0; i < _numThreads; i++)
            {


                BackgroundWorker sendWorker = new BackgroundWorker();

                sendWorker.DoWork += sendWorker_DoWork;
                sendWorker.RunWorkerAsync();

            }

            timer1.Start();
        }

		private void GenerateRequestsToFuzz()
		{

			_requestsToFuzz = new Dictionary<string,TVRequestInfo>();

			foreach (TVRequestInfo tvInfo in _requests)
			{

				byte[] reqData = _dataAccessor.LoadRequestData(tvInfo.Id);
				string reqString = Constants.DefaultEncoding.GetString(reqData);
				if (reqString.Contains(FUZZ))
				{
					//this is the only place to fuzz
					_requestsToFuzz.Add(reqString,tvInfo);
				}
				else
				{
					//parse request for parameters to fuzz
					HttpRequestInfo baseReqInfo = new HttpRequestInfo(reqString, true);
					HttpRequestInfo newReqInfo;


					Uri uri = new Uri(baseReqInfo.FullUrl);

					foreach (string key in uri.Segments)
					{
                        if (!key.Equals("/"))//skip the path element
                        {
                            newReqInfo = new HttpRequestInfo(reqString);
                            newReqInfo.Path = baseReqInfo.Path.Replace(key, FUZZ);
                            string newReqString = newReqInfo.ToString();
                            if (!newReqInfo.Path.Equals(baseReqInfo.Path))
                            {

                                AddRequestToFuzz(newReqString, tvInfo);
                            }
                        }
					}
					
					foreach (string key in baseReqInfo.QueryVariables.Keys)
					{
						newReqInfo = new HttpRequestInfo(reqString, true);
						newReqInfo.QueryVariables[key] = FUZZ;
                        AddRequestToFuzz(newReqInfo.ToString(), tvInfo);
					}

					foreach (string key in baseReqInfo.BodyVariables.Keys)
					{
						newReqInfo = new HttpRequestInfo(reqString, true);
						newReqInfo.BodyVariables[key] = FUZZ;
                        AddRequestToFuzz(newReqInfo.ToString(), tvInfo);
					}

					foreach (string key in baseReqInfo.Cookies.Keys)
					{
						newReqInfo = new HttpRequestInfo(reqString, true);
						newReqInfo.Cookies[key] = FUZZ;
                        AddRequestToFuzz(newReqInfo.ToString(), tvInfo);
					}

					foreach (var header in baseReqInfo.Headers)
					{
						newReqInfo = new HttpRequestInfo(reqString, true);
						newReqInfo.Headers[header.Name] = FUZZ;
                        AddRequestToFuzz(newReqInfo.ToString(), tvInfo);
					}
					
				}
			}
		}


        private void AddRequestToFuzz(string requestToFuzz, TVRequestInfo tvInfo)
        {
            if (!_requestsToFuzz.ContainsKey(requestToFuzz))
            {
                _requestsToFuzz.Add(requestToFuzz, tvInfo);
            }
        }

		void sendWorker_DoWork(object sender, DoWorkEventArgs e)
		{
			SendRequest();
			
		}

		private static IHttpClient GetHttpClient()
		{
			IHttpClient client = TrafficViewer.Instance.HttpClientFactory.MakeClient();
			DefaultNetworkSettings networkSettings = new DefaultNetworkSettings();
			networkSettings.CertificateValidationCallback = new RemoteCertificateValidationCallback(SSLValidationCallback.ValidateRemoteCertificate);
			if (TrafficViewerOptions.Instance.UseProxy)
			{
				WebProxy proxy = new WebProxy(TrafficViewerOptions.Instance.HttpProxyServer, TrafficViewerOptions.Instance.HttpProxyPort);
				networkSettings.WebProxy = proxy;
			}

			client.SetNetworkSettings(networkSettings);

			return client;
		}

		void FuzzWork(object sender, DoWorkEventArgs e)
		{

			Fuzz("", _maxLen);

			_fuzzOn = false;

		}


		private void Fuzz(string payload, int maxLen)
		{
			if (maxLen == 0) return;

			for (int k = 0; k < _characters.Length; k++)
			{
				if (_abort)
				{
					return;
				}
				string mutation = payload + (char)_characters[k];

				if (mutation.Length >= _minLen)
				{
					int queueCount = 0;
					do
					{
						if (_abort)
						{
							return;
						}
						lock (_lock)
						{
							queueCount = _payloads.Count;
						}
						if (queueCount > PAYLOAD_LIMIT)
						{
							Thread.Sleep(1000);
						}
						
					}
					while (queueCount > PAYLOAD_LIMIT);

					lock (_lock)
					{
						_payloads.Enqueue(mutation);
					}
				}
				Fuzz(mutation, maxLen - 1);
			}

		}


		private void SendRequest()
		{
			int count = 1;
			IHttpClient client = GetHttpClient();
			while (_fuzzOn || count > 0)
			{
				if (_abort) return;

				string mutation = null;

				lock (_lock)
				{
					if (_abort) return;
					count = _payloads.Count;
					if (count == 0)
					{
						continue;
					}
					mutation = _payloads.Dequeue();
				}

				foreach (var request in _requestsToFuzz)
				{
					string rawReq = request.Key;
                    string mutatedRequest = rawReq.Replace(FUZZ, mutation);
                    if (Utils.IsMatch(mutatedRequest, Constants.SEQUENCE_VAR_PATTERN))
                    {
                        mutatedRequest = Regex.Replace(mutatedRequest, Constants.SEQUENCE_VAR_PATTERN, DateTime.Now.Ticks.ToString());
                    }
                    if (Utils.IsMatch(mutatedRequest, Constants.GUID_VAR_PATTERN))
                    {
                        mutatedRequest = Regex.Replace(mutatedRequest, Constants.GUID_VAR_PATTERN, Guid.NewGuid().ToString());
                    }
                    
                    HttpRequestInfo reqInfo = new HttpRequestInfo(mutatedRequest);
					if (reqInfo.ContentData != null)
					{
						reqInfo.Headers["Content-Length"] = reqInfo.ContentData.Length.ToString();
					}
					reqInfo.IsSecure = request.Value.IsHttps;
					HttpResponseInfo respInfo = null;

					if (_abort) return;
					try
					{
						respInfo = client.SendRequest(reqInfo);
						if (_abort) return;
						string response = respInfo.ToString();

                        if (!String.IsNullOrEmpty(_textPattern.Text) && (Utils.IsMatch(response, _textPattern.Text) ^ _reversePattern.Checked))
						{
							lock (_lock)
							{
								if (_abort) return;
								_matches++;
							}
							_outputFile.AddRequestResponse(mutatedRequest, response, request.Value.IsHttps);
						}
					}
					catch
					{

					}
					lock (_lockCount)
					{
						_count++;
					}

					if (_abort) return;
				}

			}
		}

		private void StopClick(object sender, EventArgs e)
		{
			_abort = true;
			_fuzzOn = false;
            button1.ForeColor = Color.White;
			lock (_lock)
			{
				_payloads.Clear();		
			}
			
			timer1.Stop();
			button2.Text = "Saving...";
			button2.Enabled = false;
			_outputFile.SetState(AccessorState.Idle);
            string filePath = _fileSelector.Text;
            if (!String.IsNullOrWhiteSpace(filePath))
            {
                _outputFile.Save(filePath);
            }
			button1.Enabled = true;
			button2.Enabled = true;
			button2.Text = "Stop and Save";
			_fileSelector.Enabled = true;
			

		}

		private void timer1_Tick(object sender, EventArgs e)
		{
			long count=0;
			lock (_lockCount)
			{
				count = _count;	
			}
			
			_labelNumRequests.Text = count.ToString();
			_labelMatches.Text = _matches.ToString();

			_elapsedSeconds++;


			_textElapsed.Text = GetTime(_elapsedSeconds);

			if (count == _combinations)
			{
				StopClick(sender, e);
				return;		
			}
			
			if (count > 0 && _elapsedSeconds > 0 && _combinations > 0)
			{
				int reqPerSec = (int)(count / _elapsedSeconds);
				if (reqPerSec > 0)
				{
					long estimatedSec = (long)_combinations / reqPerSec;

					_textETA.Text = GetTime(estimatedSec);
				}
			}

			
			
			
		}

		string GetTime(long seconds)
		{
			string res = "";
			long days = seconds / (24 * 60 * 60);
			long rest = seconds % (24 * 60 * 60);

			long hours = rest / (60*60);
			rest = rest % (60*60);

			long mins = rest / 60;
			seconds = rest % 60;

			res = String.Format("{0}d {1}h {2}m {3}s",days,hours,mins,seconds);

			return res;
		}

		
		private void Fuzzer_FormClosing(object sender, FormClosingEventArgs e)
		{
			e.Cancel = _fuzzOn;
		}

        private void FuzzerLoad(object sender, EventArgs e)
        {
            string optionsPath = TrafficViewerOptions.TrafficViewerAppDataDir + "\\FuzzerOptions.xml";
            if (File.Exists(optionsPath))
            {
                _options.Load(optionsPath);
            }
            else
            {
                _options.SaveAs(optionsPath);
            }
            _textNumThreads.Text = _options.NumberOfThreads.ToString();

            UpdateRanges();

            _textPattern.Text = _options.MatchPattern;
            _reversePattern.Checked = _options.ReversePattern;
            _fileSelector.Text = _options.OutputFile;
        }

        private void UpdateRanges()
        {
            List<FuzzerRangeDefinition> defs = _options.GetRangeDefinitionList();

            if (defs.Count != 0)
            {
                _defLabel.Text = String.Empty;
                foreach (FuzzerRangeDefinition def in defs)
                {
                    if (def.Status == FuzzerRangeStatus.Disabled)
                        continue;

                    if (def.Type == FuzzerRangeType.Dictionary)
                    {
                        _defLabel.Text += Path.GetFileName(def.Value) + "; ";
                    }
                    else
                    {
                        _defLabel.Text += def.Value + "; ";
                    }
                }
            }
        }

        private void RangeSetupClick(object sender, EventArgs e)
        {
            var form = new FuzzerRangeConfig(_options);

            if (form.ShowDialog() == DialogResult.OK)
            {
                UpdateRanges();
            }

        }

       
    }
}
