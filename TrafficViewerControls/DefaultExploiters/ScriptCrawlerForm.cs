using CommonControls;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Security;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms;
using TrafficServer;
using TrafficViewerControls.Browsing;
using TrafficViewerControls.Properties;
using TrafficViewerControls.RequestList;
using TrafficViewerInstance;
using TrafficViewerSDK;
using TrafficViewerSDK.Http;

namespace TrafficViewerControls.DefaultExploiters
{
    public partial class ScriptCrawlerForm : Form
    {

        private ITrafficDataAccessor _curDataAccessor;
        private List<string> _fileList;
        private string _filePattern;
        private List<string> _foundUrls;
        private Uri _rootUri;
        private string _headers;
        private string _includePattern;
        private int MAX_INCLUDE_DEPTH = 10;
        private string _replacementPattern;
        private string _replacementString;
        private string _paramPattern;
        private string _rootDir;
        ProgressDialog _diag = new ProgressDialog();

        public ScriptCrawlerForm(ITrafficDataAccessor curDataAccessor)
        {
            _curDataAccessor = curDataAccessor;
            InitializeComponent();
        }

        private void FormForm_Load(object sender, EventArgs e)
        {
            _comboParamType.SelectedIndex = 0;
        }



        private void GenerateClick(object sender, EventArgs e)
        {
            _fileList = new List<string>();
            _foundUrls = new List<string>();
            _filePattern = _textExtensionPattern.Text;
            _includePattern = _textIncludePattern.Text;
            _replacementPattern = _textReplacementPattern.Text;
            _replacementString = _textReplacementString.Text;
            _paramPattern = _textParameterPattern.Text;
            var rootUrlString = _textUrl.Text;
            
            _rootUri = new Uri("http://localhost");
            _headers = _textRequestHeaders.Text;
            try
            {
                _rootUri = new Uri(rootUrlString);
            }
            catch (Exception ex)
            {
                ErrorBox.ShowDialog(ex.Message);
                return;
            }
            _rootDir = _textRootDirectory.Text.TrimEnd('\\');
            if (!Directory.Exists(_rootDir))
            {
                ErrorBox.ShowDialog(Resources.DirectoryDoesNotExist);
                return;
            }

            BackgroundWorker worker = new BackgroundWorker();
            worker.DoWork += GenerateRequests;
            worker.RunWorkerCompleted += WorkCompleted;
            worker.RunWorkerAsync();
            _diag.Start();
            
        }

        void WorkCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            _diag.Stop();
        }

        
        private void GenerateRequests(object sender, DoWorkEventArgs e)
        {
            _curDataAccessor.SetState(AccessorState.Loading);
            GetRecursiveListOfFiles(_rootDir);

            foreach (string fileName in _fileList)
            {
                try
                {
                    string requestPath = fileName.Replace(_rootDir, "");
                    requestPath = requestPath.Replace('\\', '/').TrimStart('/');
                    requestPath = Regex.Replace(requestPath, _replacementPattern, _replacementString);
                    var requestUri = new Uri(_rootUri, requestPath);
                    requestPath = requestUri.AbsolutePath;
                    string host = requestUri.Host;
                    int port = requestUri.Port;

                    var getRequest = new HttpRequestInfo(String.Format("GET {0} HTTP/1.1\r\n{1}\r\n\r\n", requestPath, _headers), true);
                    var postRequest = new HttpRequestInfo(String.Format("POST {0} HTTP/1.1\r\n{1}\r\n", requestPath, _headers), true);
                    postRequest.Headers["Content-Type"] = "application/x-www-form-urlencoded";

                    getRequest.Host = postRequest.Host = host;
                    getRequest.Port = postRequest.Port = port;

                    getRequest.IsSecure = postRequest.IsSecure = _rootUri.Scheme.Equals("https", StringComparison.OrdinalIgnoreCase);

                    string fileContents = GetFileContents(fileName, 0);

                    var parameters = GetParametersAndValues(_paramPattern, fileContents);

                    //add requests for all parameter values combinations
                    GenerateRequestsBasedOnParameters(getRequest, postRequest, parameters);


                    //parse all links and forms from the content
                    ExtractLinks(fileContents);

                    //parse forms
                    ExtractForms(fileContents);

                }
                catch (Exception ex)
                {
                    SdkSettings.Instance.Logger.Log(System.Diagnostics.TraceLevel.Error, ex.Message);
                }

            }

            foreach (var url in _foundUrls)
            {
                if (Uri.IsWellFormedUriString(url, UriKind.Absolute))
                {
                    Uri uri = new Uri(url);
                    //generate get requests
                    var getRequest = new HttpRequestInfo(String.Format("GET {0} HTTP/1.1\r\n{1}\r\n\r\n", uri.PathAndQuery, _headers), true);
                    getRequest.Host = uri.Host;
                    getRequest.Port = uri.Port;
                    AddHttpRequest(getRequest);
                }
            }
            _curDataAccessor.SetState(AccessorState.Idle);
        }

                
        /// <summary>
        /// Adds a request to the data accessor
        /// </summary>
        /// <param name="request"></param>
        private void AddHttpRequest(HttpRequestInfo request)
        {
            var reqInfo = new TVRequestInfo();
            reqInfo.Host = request.Host;
            reqInfo.IsHttps = request.IsSecure;

            byte [] rawRequest = request.ToArray();

            reqInfo.RequestLine = HttpRequestInfo.GetRequestLine(rawRequest);
            reqInfo.Description = "Script Explore";

            var id = _curDataAccessor.AddRequestInfo(reqInfo);
            _curDataAccessor.SaveRequest(id, rawRequest);
           
        }

        /// <summary>
        /// Generates all possible parameter combinations
        /// </summary>
        /// <param name="getRequest"></param>
        /// <param name="postRequest"></param>
        /// <param name="parameters"></param>
        private void GenerateRequestsBasedOnParameters(HttpRequestInfo getRequest, HttpRequestInfo postRequest, List<string> parameters)
        {
            if (parameters.Count == 0)
            {
                AddHttpRequest(getRequest);
                AddHttpRequest(postRequest);
            }
            else
            {

                foreach (string parameterString in parameters)
                {
                    string[] nameValuePairs = parameterString.Split('&');

                    getRequest.QueryVariables.Clear();
                    postRequest.BodyVariables.Clear();

                    foreach (string nameValuePair in nameValuePairs)
                    {
                        string[] nameValueArray = nameValuePair.Split('=');

                        if(nameValueArray.Length == 2)
                        {
                            var paramName = nameValueArray[0];
                            var paramVal = nameValueArray[1];
                            getRequest.QueryVariables.Add(paramName, paramVal);
                            postRequest.BodyVariables.Add(paramName, paramVal);
                        }
                    }
                    AddHttpRequest(getRequest);
                    AddHttpRequest(postRequest);
                }
            }
        }

        /// <summary>
        /// Generates all parameter combinations recursively
        /// </summary>
        /// <param name="plist"></param>
        /// <param name="paramNames"></param>
        /// <param name="built"></param>
        /// <param name="depth"></param>
        /// <param name="results"></param>
        private void GenCombinations(List<List<string>> plist, List<string> paramNames, string built, int depth, List<string> results)
        {
             
            if (depth >= plist.Count())
            {
                results.Add(built.TrimEnd('&'));
                return;
            }

            List<string> next = plist[depth];
            built += paramNames[depth] + "=";
            foreach (var option in next)
            {
                GenCombinations(plist, paramNames, built + option + "&", depth + 1, results);
            }
        }



        private List<string> GetParametersAndValues(string paramPattern, string fileContents)
        {
            MatchCollection matches = Regex.Matches("", "x");
            if (!String.IsNullOrEmpty(paramPattern))
            {
                matches = Regex.Matches(fileContents, paramPattern);
            }

            var parameters = new Dictionary<string, List<string>>();

            foreach (Match match in matches)
            {
                //extract parameter name
                if (match.Groups.Count > 1)
                {
                    string paramName = match.Groups[1].Value;
                    if (!String.IsNullOrWhiteSpace(paramName))
                    {

                        List<string> valueList = GetParameterValues(fileContents, paramName);
                        if (!parameters.ContainsKey(paramName))
                        {
                            parameters.Add(paramName, valueList);
                        }
                        else
                        {
                            var existingValues = parameters[paramName];
                            foreach (string val in valueList)
                            {
                                if (!existingValues.Contains(val))
                                {
                                    existingValues.Add(val);
                                }
                            }
                        }
                    }
                }
            }

            //now change the parameters values to a list
            var listOfValueLists = new List<List<string>>();
            var parameterNames = new List<string>();
            
            foreach(var paramName in parameters.Keys)
            {
                parameterNames.Add(paramName);    
                listOfValueLists.Add(parameters[paramName]);
            }

            var results = new List<string> ();
            
            GenCombinations(listOfValueLists, parameterNames, "", 0, results);

            return results;
        }

        private void ExtractForms(string fileContents)
        {
            MatchCollection matches = Regex.Matches(fileContents, "(?si)<form.*?</form>");
            foreach (Match m in matches)
            {
                var form = m.Value;
                //extract the form uri and method
                var method = Utils.RegexFirstGroupValue(form, "(?si)method\\s*=\\s*['\"]?(\\w+)").ToLower();
                if (String.IsNullOrWhiteSpace(method))
                {
                    method = "get";
                }

                var url = Utils.RegexFirstGroupValue(form, "(?si)action\\s*=\\s*['\"]?(\\w+)");

                //if the url contains script in it or is malformed skip it
                if (!Uri.IsWellFormedUriString(url, UriKind.RelativeOrAbsolute)) continue;

                Uri formUri = _rootUri;
                if (!String.IsNullOrWhiteSpace(url))
                {
                    formUri = new Uri(url);
                    if (!formUri.IsAbsoluteUri)
                    {
                        formUri = new Uri(_rootUri, formUri);
                    }
                }

                //extract form fields
                var fieldMatches = Regex.Matches(form, "(?si)<input.*?</input>");
                HttpRequestInfo formReqInfo;
                if (method.Equals("get"))
                {
                    formReqInfo = new HttpRequestInfo(String.Format("GET {0} HTTP/1.1\r\n{1}\r\n\r\n", formUri.PathAndQuery, _headers), true);
                }
                else
                {
                    formReqInfo = new HttpRequestInfo(String.Format("POST {0} HTTP/1.1\r\n{1}\r\n", formUri.PathAndQuery, _headers), true);
                    formReqInfo.Headers["Content-Type"] = "application/x-www-form-urlencoded";

                }

                formReqInfo.Host = formUri.Host;
                formReqInfo.Port = formUri.Port;

                foreach (Match fm in fieldMatches)
                {
                    //get input name and value
                    var input = fm.Value;
                    var name = Utils.RegexFirstGroupValue(form, "(?si)name\\s*=\\s*['\"]?(\\w+)");
                    var value = Utils.RegexFirstGroupValue(form, "(?si)value\\s*=\\s*['\"]?(\\w+)");
                    if (method.Equals("get"))
                    {
                        formReqInfo.QueryVariables.Add(name, value);
                    }
                    else
                    {
                        formReqInfo.BodyVariables.Add(name, value);
                    }
                }

                //finally

                if (method.Equals("get"))//add to the list of urls
                {
                    url = formReqInfo.FullUrl;
                    if (!_foundUrls.Contains(url))
                    {
                        _foundUrls.Add(url);
                    }
                }
                else
                {
                    //add the post request on the spot
                    TVRequestInfo reqInfo = _curDataAccessor.GetRequestInfo(
                        _curDataAccessor.AddRequestResponse(formReqInfo.ToString(), "")
                    );

                    reqInfo.IsHttps = formUri.Scheme.Equals("https",StringComparison.OrdinalIgnoreCase);
                    _curDataAccessor.UpdateRequestInfo(reqInfo);

                }

            }
        }

        /// <summary>
        /// Parses all links
        /// </summary>
        /// <param name="fileContents"></param>
        private void ExtractLinks(string fileContents)
        {
            //parse full links
            MatchCollection matches = Regex.Matches(fileContents, "https?://[^\"']+", RegexOptions.IgnoreCase);

            foreach (Match m in matches)
            {
                var url = m.Value;
                if (Uri.IsWellFormedUriString(url, UriKind.Absolute) && !_foundUrls.Contains(url))
                {
                    _foundUrls.Add(url);
                }
            }

            //parse relative links
            matches = Regex.Matches(fileContents, "(?:href|location)\\s*=\\s*['\"]?([^'\"\\s]+)", RegexOptions.IgnoreCase);
            foreach (Match m in matches)
            {
                if (m.Groups.Count > 1)
                {
                    var url = m.Groups[1].Value;
                    if (Uri.IsWellFormedUriString(url, UriKind.Relative))
                    {
                        var uri = new Uri(_rootUri, url);//combine with the root uri
                        url = url.ToString();
                        if (!_foundUrls.Contains(url))
                        {
                            _foundUrls.Add(url);
                        }
                    }
                }
            }

        }

        /// <summary>
        /// Gets script file contents resolving includes recursively
        /// </summary>
        /// <param name="fileName"></param>
        /// <returns></returns>
        private string GetFileContents(string fileName, int depth)
        {
            
            if (depth > MAX_INCLUDE_DEPTH || !File.Exists(fileName)) return String.Empty;
            
            //extract parameters string
            string fileContents = File.ReadAllText(fileName);
            var currentDir = new FileInfo(fileName).Directory.FullName;
            //resolve includes
            MatchCollection matches = Regex.Matches(fileContents,_includePattern);
            foreach (Match m in matches)
            {
                if (m.Groups.Count > 1)
                {
                    var includeFileName = FindInclude(currentDir, m.Groups[1].Value.Replace("/", "\\"));
                    var includeFileContents = GetFileContents(includeFileName, depth + 1);
                    if (!String.IsNullOrEmpty(includeFileContents))
                    {
                        fileContents = fileContents.Replace(m.Value,includeFileContents);
                    }
                }
            }
            return fileContents;
        }

        /// <summary>
        /// Finds an include in the list of existing files
        /// </summary>
        /// <param name="currentDir"></param>
        /// <param name="includeName"></param>
        /// <returns></returns>
        private string FindInclude(string currentDir, string includeName)
        {
            foreach (string file in _fileList)
            {
                if (file.Contains(includeName))
                {
                    return file;

                }
            }
            return Path.Combine(currentDir,includeName);
        }

        /// <summary>
        /// Returns a parameter value
        /// </summary>
        /// <param name="fileContents"></param>
        /// <param name="paramName"></param>
        /// <returns></returns>
        private List<string> GetParameterValues(string fileContents, string paramName)
        {
            List<string> valueList = new List<string>();
            //try to obtain a value out of the content default values or comparisons

            MatchCollection matches = Regex.Matches(fileContents,String.Format("{0}(?:['\"]\\])?\\s*==?\\s*(['\"]?[^\\s\\)&|;]+)", Regex.Escape(paramName)));

            if (matches.Count > 0)
            {
                foreach (Match m in matches)
                {
                    if (m.Groups.Count > 1)
                    {
                        var value = m.Groups[1].Value;
                        //check if the value is a string or is another parameter construct
                        if (!String.IsNullOrWhiteSpace(value))
                        {
                            if (Utils.IsMatch(value, "^['\"][^'\"$]+['\"]"))
                            {
                                //this is the case of a simple string
                                value = Utils.RegexFirstGroupValue(value, "['\"]([^'\"$]+)['\"]");
                            }
                            else
                            {
                                if (!Utils.IsMatch(value, "^(true|null|false|\\d+)$")) //value is not numeric or boolean
                                {
                                    //this is probably another parameter value try to get it
                                    var otherParam = Utils.RegexFirstGroupValue(value, "(\\$?[\\w_]+)");
                                    if (!String.IsNullOrWhiteSpace(otherParam))
                                    {
                                        //look for a string in the file
                                        value = Utils.RegexFirstGroupValue(fileContents,
                                    String.Format("{0}(?:['\"]\\])?\\s*==?\\s*['\"]([^\"']+)['\"]", Regex.Escape(otherParam)));
                                    }
                                    else
                                    {
                                        value = String.Empty;
                                    }
                                }

                            }
                        }
                        if (!String.IsNullOrWhiteSpace(value)) 
                        {
                            value = Regex.Unescape(value); //unescape strings from programming languages
                            value = Utils.UrlEncode(value);
                            if (!valueList.Contains(value))
                            {
                                valueList.Add(value);
                            }
                        }
                    }
                }
            }
            
            if(valueList.Count == 0)
            {
                var value = "1234";
                if (Utils.IsMatch(paramName, "mail"))
                {
                    value = "test@blackops.local";
                }
                else if (Utils.IsMatch(paramName, "\bis"))
                {
                    value = "true";
                }
                else if (Utils.IsMatch(paramName, "\bsort"))
                {
                    value = "asc";
                }
                valueList.Add(Utils.UrlEncode(value));
            }
            return valueList;
        }


        private void GetRecursiveListOfFiles(string dir)
        {
            try
            {
                foreach (string fileName in Directory.GetFiles(dir))
                {
                    if (Utils.IsMatch(fileName, _filePattern))
                    {
                        _fileList.Add(Path.GetFullPath(fileName));
                    }
                }

                foreach (string directory in Directory.GetDirectories(dir))
                {
                    GetRecursiveListOfFiles(directory);
                }
            }
            catch (Exception ex)
            {
                SdkSettings.Instance.Logger.Log(System.Diagnostics.TraceLevel.Error, ex.Message);
            }
        }

        private void SelectFolder(object sender, EventArgs e)
        {
            if (_openFileDialog.ShowDialog() == DialogResult.OK)
            {

                _textRootDirectory.Text = _openFileDialog.FileName.Replace(Path.GetFileName(_openFileDialog.FileName), "");
            }
        }

        private void _textReplacementPattern_TextChanged(object sender, EventArgs e)
        {

        }

        private void label12_Click(object sender, EventArgs e)
        {

        }








    }
}
