/**
Copyright 2019 Trend Micro, Incorporated, All Rights Reserved.
SPDX-License-Identifier: Apache-2.0
 */
using CommonControls;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using TrafficViewerControls.Properties;
using TrafficViewerControls.RequestList;
using TrafficViewerSDK;
using TrafficViewerSDK.Exploiters;
using TrafficViewerSDK.Http;
using Testing;
using CustomTestsUI;
using System.Diagnostics;
using TrafficViewerInstance;
using System.Net;
using System.Net.Security;
using TrafficViewerControls.Browsing;
using System.Threading;
using System.IO;

namespace TrafficViewerControls.DefaultExploiters
{
    public class CustomTestsExploiter : IExploiter, ITestController, ITestRunner
    {
        private TrafficViewerFile _trafficFile = TrafficViewer.Instance.TrafficViewerFile;
        private List<TVRequestInfo> _selectedRequests;
        private IHttpClientFactory _httpClientFactory = TrafficViewer.Instance.HttpClientFactory;

        private Queue<TVRequestInfo> _requestsToTest = new Queue<TVRequestInfo>();

        private bool _runnable = false;
        private CustomTestsFile _testFile;
        private Queue<string> _multiStepsToTest;
        private DefaultNetworkSettings _netSettings;
        private bool _verbose = false;

        public string Caption
        {
            get { return "Custom Tests"; }
        }

        public CustomTestsExploiter()
        {

            _netSettings = new DefaultNetworkSettings();
            if (TrafficViewerOptions.Instance.UseProxy)
            {
                _netSettings.WebProxy = new WebProxy(
                    TrafficViewerOptions.Instance.HttpProxyServer,
                    TrafficViewerOptions.Instance.HttpProxyPort);
            }
            _netSettings.CertificateValidationCallback = new RemoteCertificateValidationCallback(SSLValidationCallback.ValidateRemoteCertificate);
        }

        public void Execute(ITrafficDataAccessor curDataAccessor,
            List<TVRequestInfo> selectedRequests,
            IHttpClientFactory curHttpClientFactory)
        {

            _trafficFile = curDataAccessor as TrafficViewerFile;
            if (_trafficFile == null)
            {
                Log("Invalid Traffic File Given");
            }

            _selectedRequests = selectedRequests;
            _httpClientFactory = curHttpClientFactory;

            SetupForm setupForm = new SetupForm(this, TrafficViewerOptions.TrafficViewerAppDataDir, _netSettings);
            setupForm.Show();
        }

        /// <summary>
        /// Handles logging
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public void Log(string format, params object[] args)
        {
            if (_verbose)
            {
                HttpServerConsole.Instance.WriteLine(LogMessageType.Error, format, args);
            }
        }


        public string SendTest(string mutatedRequest, string host, int port, bool useSSL)
        {
            HttpRequestInfo reqInfo = new HttpRequestInfo(mutatedRequest, false);
            reqInfo.IsSecure = useSSL;
            reqInfo.Host = host;
            reqInfo.Port = port;
            IHttpClient client = _httpClientFactory.MakeClient();
            client.SetNetworkSettings(_netSettings);
            DateTime reqTime = DateTime.Now;


            HttpResponseInfo resp = null;


            TVRequestInfo tvReqInfo = null;

            if (_verbose)
            {
                tvReqInfo = SaveRequest("Custom Test", reqInfo, useSSL, String.Empty, reqTime, reqTime, "");
            }

            try
            {
                resp = client.SendRequest(reqInfo);
            }
            catch
            { }
            DateTime respTime = DateTime.Now;

            string response;
            if (resp != null)
            {
                PatternTracker.Instance.UpdatePatternValues(resp);
                response = resp.ToString();
                if (tvReqInfo != null)
                {
                    tvReqInfo.ResponseTime = DateTime.Now;
                    _trafficFile.UpdateRequestInfo(tvReqInfo);
                    _trafficFile.SaveResponse(tvReqInfo.Id, resp.ToArray());
                }
            }
            else
            {
                response = String.Empty;
            }

            return response;
        }

        public string UpdateSessionIds(string mutatedRequest, bool useSSL)
        {
            return PatternTracker.Instance.UpdateRequest(mutatedRequest);
        }

        public void HandleIssueFound(string origRawReq, string origRawResp, Uri requestUri, string englishIssueTypeName, string parameterName, List<string> testRequestList, List<string> testResponseList, string validation, string comment)
        {
            string testRequest = String.Empty;
            string testResponse = String.Empty;
            int count = testRequestList.Count;
            for (int idx = 0; idx < count; idx++)
            {
                testRequest = testRequestList[idx];
                testResponse = testResponseList[idx];
                SaveRequest(String.Format("{0} {1}/{2} - Vulnerability", englishIssueTypeName, idx+1, count), new HttpRequestInfo(testRequest), requestUri.Scheme.Equals("https"), testResponse, DateTime.Now, DateTime.Now, validation);   
            }

            
        }

        private TVRequestInfo SaveRequest(string description, HttpRequestInfo reqInfo, bool isSecure, string testResponse, DateTime requestTime, DateTime responseTime, string validation)
        {
            TVRequestInfo newReqInfo = new TVRequestInfo();
            newReqInfo.Description = description;
            newReqInfo.Validation = validation;
            newReqInfo.Host = reqInfo.Host;
            newReqInfo.ResponseStatus = HttpResponseInfo.GetResponseStatus(testResponse);
            newReqInfo.RequestTime = requestTime;
            
            newReqInfo.IsHttps = isSecure;
            newReqInfo.ThreadId = Utils.GetCurrentWin32ThreadId().ToString();
            newReqInfo.RequestLine = reqInfo.RequestLine;
            int newId = _trafficFile.AddRequestInfo(newReqInfo);
            _trafficFile.SaveRequest(newId, Constants.DefaultEncoding.GetBytes(reqInfo.ToString(false)));
            if (!String.IsNullOrWhiteSpace(testResponse))
            {
                _trafficFile.SaveResponse(newId, Constants.DefaultEncoding.GetBytes(testResponse));
                newReqInfo.ResponseTime = responseTime;
            }
            return newReqInfo;
        }

        public void Pause()
        {
            _runnable = false;
        }

        public void Cancel()
        {
            _runnable = false;
            _requestsToTest.Clear();
        }

        public int LeftToTest
        {
            get { return _requestsToTest.Count; }
        }

        public void Run()
        {
            _runnable = true;


            TestSelectedRequests();

            TestMultiSteps();

            
            _trafficFile.SetState(AccessorState.Idle);
            _runnable = false;
        }


        private void TestSelectedRequests()
        {
            var customTests = _testFile.GetCustomTests().Values;
            Tester tester = new Tester(this, _testFile);
            if (_requestsToTest.Count == 0)
            {
                //load the requests to test
                foreach (var tvReqInfo in _selectedRequests)
                {
                    _requestsToTest.Enqueue(tvReqInfo);
                }
            }

            _trafficFile.SetState(AccessorState.Loading);

            while (_runnable && _requestsToTest.Count > 0)
            {
                TVRequestInfo workingEntry = _requestsToTest.Peek();
                //check the request;
                byte[] reqBytes = _trafficFile.LoadRequestData(workingEntry.Id);
                byte[] respBytes = _trafficFile.LoadResponseData(workingEntry.Id);
                HttpRequestInfo workingReqInfo = null;
                if (reqBytes == null)
                {
                    Log("SELECT A NEW REQUEST");
                    _requestsToTest.Dequeue(); //remove the request;
                    continue;
                }
                else
                {
                    workingReqInfo = new HttpRequestInfo(reqBytes, true);
                    workingReqInfo.IsSecure = workingEntry.IsHttps;
                }


                string rawRequest = workingReqInfo.ToString();
                string rawResponse = respBytes != null ? Constants.DefaultEncoding.GetString(respBytes) : String.Empty;
                if (ShouldBeTested(rawRequest, _testFile.GetAttackTargetList()))
                {

                    MultiThreadedTestExecution testExecution = new MultiThreadedTestExecution(tester, rawRequest, rawResponse, new Uri(workingReqInfo.FullUrl), _testFile.NumberOfThreads);

                    bool containsFuzz = rawRequest.Contains(Constants.FUZZ_STRING);

                    foreach (CustomTestDef testDef in customTests)
                    {
                        if (containsFuzz)
                        {
                            testExecution.TestsQueue.Enqueue(new TestJob(String.Empty, String.Empty, RequestLocation.Path, testDef));

                        }
                        else
                        {
                            //iterate through parameters, cookies and headers
                            foreach (var parameter in workingReqInfo.PathVariables)
                            {
                                testExecution.TestsQueue.Enqueue(new TestJob(parameter.Key, parameter.Value, RequestLocation.Path, testDef));
                            }

                            foreach (var parameter in workingReqInfo.QueryVariables)
                            {
                                testExecution.TestsQueue.Enqueue(new TestJob(parameter.Key, parameter.Value, RequestLocation.Query, testDef));
                            }

                            foreach (var parameter in workingReqInfo.BodyVariables)
                            {
                                testExecution.TestsQueue.Enqueue(new TestJob(parameter.Key, parameter.Value, RequestLocation.Body, testDef));
                            }

                            if (!_testFile.TestOnlyParameters)
                            {
                                foreach (var header in workingReqInfo.Headers)
                                {
                                    if (!header.Name.Equals("Host"))
                                    {
                                        testExecution.TestsQueue.Enqueue(new TestJob(header.Name, header.Value, RequestLocation.Headers, testDef));
                                    }
                                }

                                foreach (var cookie in workingReqInfo.Cookies)
                                {
                                    testExecution.TestsQueue.Enqueue(new TestJob(cookie.Key, cookie.Value, RequestLocation.Cookies, testDef));
                                }
                            }
                        }
                    }

                    testExecution.StartTestsAsync();

                    while (testExecution.IsRunning)
                    {
                        if (!_runnable)
                        {
                            testExecution.CancelTests();
                        }
                        //wait for the test execution to complete
                        HttpServerConsole.Instance.WriteLine(LogMessageType.Notification,
                                  "Requests in queue: {0}, Tests in queue for current request: {1}.",
                                  _requestsToTest.Count, testExecution.TestsQueue.Count);
                        Thread.Sleep(10);
                    }

                    HttpServerConsole.Instance.WriteLine(LogMessageType.Notification,
                                     "Test execution completed.");

                }
                if (_requestsToTest.Count > 0)
                {
                    _requestsToTest.Dequeue();
                }
            }
        }

        private void TestMultiSteps()
        {
            //we also initialize all multi-step operations
            List<string> multiStepList = _testFile.GetMultiStepList();

            _multiStepsToTest = new Queue<string>();


            foreach (string path in multiStepList)
            {
                if (File.Exists(path))
                {
                    _multiStepsToTest.Enqueue(path);
                }
                else
                {
                    HttpServerConsole.Instance.WriteLine(LogMessageType.Error,
                                      "Multi-Step path '{0}' does not exist.", path);
                }
            }

            while (_multiStepsToTest.Count > 0)
            {
                if (!_runnable) return;

                string path = _multiStepsToTest.Peek();

                bool isAbl = path.EndsWith(".login");
                TrafficViewerFile htd = new TrafficViewerFile();
                if (isAbl)
                {
                    HttpServerConsole.Instance.WriteLine(LogMessageType.Error, "ABL files are not supported");
                    continue;
                }
                else
                {
                    htd.Open(path);
                }

                SequentialAttackProxy proxy = GetTestProxy(_netSettings, true) as SequentialAttackProxy;
                proxy.Start();

                DefaultNetworkSettings netSettings = new DefaultNetworkSettings();
                netSettings.WebProxy = new WebProxy(proxy.Host, proxy.Port);
                netSettings.CertificateValidationCallback = _netSettings.CertificateValidationCallback;
                RequestSender.RequestSender reqSender = new RequestSender.RequestSender(netSettings);

                do
                {
                    reqSender.Send(htd);
                }
                while (!proxy.TestComplete && _runnable);

                proxy.Stop();

                if (_runnable)
                {
                    _multiStepsToTest.Dequeue();
                }
            }
        }


        private bool ShouldBeTested(string rawRequest, Dictionary<string, AttackTarget> attackTargetLists)
        {
            foreach (var target in attackTargetLists.Values)
            {
                if (target.Status == AttackTargetStatus.Enabled &&
                    Utils.IsMatch(rawRequest,target.RequestPattern))
                {
                    return true;
                }
            }
            return false;

        }

        public bool IsRunning
        {
            get { return _runnable; }
        }

        public void SetTestFile(CustomTestsFile testFile)
        {
            _testFile = testFile;
            _verbose = testFile.Verbose;
        }

        public BaseAttackProxy GetTestProxy(INetworkSettings networkSettings, bool isSequential)
        {
            BaseAttackProxy testProxy;
            if (isSequential)
            {
                testProxy = new SequentialAttackProxy(this, _testFile, _trafficFile, TrafficViewerOptions.Instance.TrafficServerIp, TrafficViewerOptions.Instance.TrafficServerPort);
            }
            else
            {
                testProxy = new DriveByAttackProxy(this, _testFile, _trafficFile, TrafficViewerOptions.Instance.TrafficServerIp, TrafficViewerOptions.Instance.TrafficServerPort);
            }
            testProxy.NetworkSettings.WebProxy = networkSettings.WebProxy;
            testProxy.NetworkSettings.CertificateValidationCallback = networkSettings.CertificateValidationCallback;

            return testProxy;
        }


        public string GetPatternOfRequestsToTest()
        {
            return null;
        }
    }
}
